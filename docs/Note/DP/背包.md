# 背包
在C++中，​**背包问题（Knapsack Problem）​**​ 是一个经典的优化问题，主要用于在**资源受限条件下进行价值最大化决策**，核心思想是通过**动态规划**来实现的。

为了更好的理解不同的背包之间的区别，在讲一种背包之前我们会先看一个例子。
## 01 背包

>题目简介：有 `N` 个物品和一个容量为 `W` 的背包，每个物品价值为 `v[i]`， 重量为 `c[i]` 。在选出若干个物品在满足容量不超过 `W` 时，求最大价值是多少？

这是最基础的背包问题，观察后发现每个物品要么选（1），要么不选（0），所以我们通常称这种题型为 01背包。

### 思路
我们可以定义一个状态：`dp[i][j]` 代表前 `i` 个物品选恰好重量为 `j` 时，可以获得的最大价值。那么决策显然为两个：选或不选。如果选择装入当前物品，那么我们需要让背包腾出至少 `c[i]` 个容量用于装这个物品，而价值则加上这个物品的价值，即 `v[i]`。如果不选择装入当前物品，那么就是同样的空间装前 `i - 1` 个物品。

我们可以画一个表格来直接的理解：
![image lost](../../assets/images/knapsack1.png)

通过整理和表格我们发现状态转移如下：
$$
dp[i][j] = \max \begin{cases}
dp[i - 1][j]
\newline
dp[i - 1][j - c[i]] + v[i]
\end{cases}
$$
### Code
下面是一个 01背包在转移时的代码：
```cpp
for (int i = 1; i <= n; i++) {
	for (int j = c[i]; j <= W; j++) {
		dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + v[i])
	}
}
```
### 复杂度
这样的时间复杂度是 $O(NW)$，空间复杂度为 $O(NW)$。
### 优化（滚动数组）
01 背包的时间复杂度是不可优化的了，而空间复杂度可以优化为 $O(W)$ ，这个时候我们就需要使用滚动数组了。
#### 观察
通过观察发现 `dp[i][j]` 只可能是从上一行而且不超过这一列转移过来。具体来说 `dp[i][j]` 只可能是从 `dp[u][v]` 转移过来且 $1 \le u \le i - 1, \ 1 \le v \le j$ 。所以我们可以把 `N` 行压成 1 行，但是我们需要倒序来保证不把之前的覆盖。

#### Code
下面是一个使用了滚动数组的 01背包：
```cpp
for (int i = 1; i <= n; i++) {
	for (int j = W; j >= c[i]; j--) {
		dp[j] = max(dp[j], dp[j - c[i]] + v[i]);
	}
}
```
#### 复杂度
时间复杂度无法进行优化，即 $O(NW)$ ，空间复杂度为 $O(W)$
### 总结
01 背包是一个只有两个决策（选或不选）的背包。

状态转移：**扣除花费获得价值**。

---
## 完全背包

> 题目简介：有 `N` **种**物品和一个容量为 `W` 的背包， **每种物品可以拿任意个**，每种物品价值为 `v[i]`， 重量为 `c[i]` 。在选出若干个物品在满足容量不超过 `W` 时，求最大价值是多少？

观察上面题目发现跟 01 背包有些区别，这次变成了有 `N` 种，然后每种可以去任意个数。这种没有数量限制的题目我们统称为完全背包。
### 思路
我们发现完全背包非常类似 01 背包。而不同的是，01 背包的决策是要或者不要，但是完全背包的决策是要 0 个， 要 1 个， $\cdots$  要 $\lfloor \frac{W}{c[i]} \rfloor$ 个。具体来说就是要 `k` 个且 $0 \le k \le \lfloor \frac{W}{c[i]} \rfloor$ 。我们定义 `dp[i][j]` 代表前 `i` 个物品选恰好重量为 `j` 时，可以获得的最大价值。我们可以画出下面的表格来辅助我们理解转移：
![image lost](../../assets/images/knapsack2.png)

转移如下：
$$
dp[i][j] = \max \begin{cases} 
dp[i-1][j] \newline
dp[i][j - k \times c[i]] + k \times v[i]
\end{cases}
\quad
\text{subject to:} \quad 
\boxed{\begin{array}{l} 
0 \leq k \leq \frac{W}{c[i]} \newline
k \times c[i] \leq j 
\end{array}}
$$
### Code
下面为完全背包的转移时的代码
```cpp
for (int i = 1; i <= n; i++) {
	for (int j = 0; j <= W; j++) {
		dp[i][j] = dp[i - 1][j];
		
		for (int k = 0; k <= W / c[i]) {
			dp[i][j] = max(dp[i][j], dp[i][j - k * c[i]] + k * v[i]);
		}
	}
}
```
### 复杂度
时间复杂度为 $O(N{W} ^ {2})$，是比较大的。空间复杂度为 $O(NW)$
### 优化 
#### 思路
先观察 01 背包和完全背包在二维下转移的区别，发现一个是可以从
 01 背包滚动数组后需要倒序是为了保证 `dp[i]` 是从状态 `dp[i - 1][j - c[i]]` 转移而来，而完全背包是可以从自己这一行转移过来，所以 `for` 循环需要顺序写来保证可以从 `dp[i][j - k * c[i]]` 转移而来。

#### Code
下面是滚动数组后的完全背包：
```cpp
for (int i = 1; i <= n; i++) {
	for (int j = 0; j <= W; j++) {
		dp[j] = max(dp[j], dp[j - c[i]] + v[i]);
	}
}
```

#### 复杂度
我们发现之前的双重循环的时间复杂度是 $O(N{W}^{2})$ 而，优化后的时间复杂度是 $O(NW)$ 。

空间复杂度从 $O(NW) \to O(W)$ 。

---
## 多重背包

> 题目简介：有 `N` **种**物品和一个容量为 `W` 的背包， 每种物品可以**拿 `m[i]` 个**，每种物品价值为 `v[i]`， 重量为 `c[i]` 。在选出若干个物品在满足容量不超过 `W` 时，求最大价值是多少？

这次题目给定了 `N` 中物品和每种物品可拿的数量，我们通常将这种类型的背包叫做**多重背包**。多重背包更完全背包的唯一区别就是完全背包的每种物品可拿无限个，而多重背包的每种物品有一个限制。

### 思路
完全背包是通过枚举一个 `k` 来表示拿 `k` 个，而这个 `k` 的上限是 $\frac{W}{c[i]}$。而多重背包的上限题目已给出，即 `m[i]` 。所以转移就是完全背包的转移将 `k` 的上限替换为 `m[i]` 就可以了。

$$
dp[i][j] = \max \begin{cases}
dp[i - 1][j] \newline
dp[i][j - k \times c[i]] + k \times v[i]
\end{cases}
\quad
\text{subject to:} \quad 
\boxed{\begin{array}{l} 
0 \leq k \leq m[i] \newline
k \times c[i] \leq j 
\end{array}}
$$

### Code
下面是多重背包转移时的代码：
```cpp
for (int i = 1; i <= n; i++) {
	for (int j = 0; j <= W; j++) {
		for (int k = 0; k <= m[i]; k++) {
			dp[i][j] = max(dp[i][j], dp[i - 1][j - k * c[i]] + k * v[i]);
		}
	}
}
```

### 二进制优化
二进制优化是一种将多重背包转换为01背包的巧妙方法，大幅降低算法的时间复杂度。这种优化利用了**二进制表示的特性**，将物品拆分后用01背包的方法解决。

> 我们通过二进制拆分，将**物品数量限制**转化为**物品组合选择**，从而将多重背包问题转化为01背包问题，来优化时间。

#### 思路
我们将一个数拆成以下形式：

$$
2^1 + 2^2 + 2^3 + \cdots + 2^x + \text{Remain}
$$
**注：$\text{Reamin}$ 表示剩余部分。**

我们也可以通过以下图片来助于我们理解，下面图片展示了把一个数拆成上面所说的格式。左下角为二的整数次幂，右下角是剩余的数量。

![](../../assets/images/knapsack3.png)
### 单调队列优化
待更新

---